# Distributed CLI Grep Utility

Распределённая CLI-утилита на Go, реализующая функциональность `grep`
с поддержкой quorum-агрегации и параллельной обработки на нескольких узлах.

Проект демонстрирует проектирование master–slave архитектуры,
работу с HTTP, конкурентность (goroutines, context, chan), агрегацию результатов
и контроль консистентности ответов.

---

## Ключевые особенности

- Master–Slave архитектура
- Параллельная обработка данных
- Quorum-based валидация результатов
- Поддержка stdin и нескольких файлов
- Graceful shutdown (SIGINT / SIGTERM)
- Интеграционные тесты с сравнением с системным `grep`

---

## Архитектурные решения

### Master

- Принимает CLI-запрос
- Читает вход (stdin / файлы)
- Делит вход на задания (каждое задание имеет UUID)
- Выполняет healthcheck узлов
- Рассылает задания всем slave
- Агрегирует ответы
- Завершает выполнение задания при достижении quorum
- Отменяет HTTP-запросы через `context cancellation`
- Проверяет консистентность ответов через hash-суммы

### Slave

- Получает задание по HTTP
- Выполняет поиск (строковый или regexp)
- Формирует ответ
- Вычисляет hash результата
- Возвращает данные мастеру

---

## Возможности

- Параллельная обработка входящих данных на нескольких slave-нодах;
- CLI-интерфейс;
- Unit-тесты;
- Сравнение результата с системным `grep` в интеграционном тесте через Makefile;
- Поддержка обычного(флаг '-F') и regexp-поиска;
- Поддержка флагов `grep` ('-c', '-n', '-v', '-i', контексты '-A'/'-B'/'-C');
- Доп. флаги: 
    - '-mode' - указывает режим запуска приложения: 'master'/'slave';
    - '-node' - позволяет перечислить адреса slave-нод при запуске мастера;
    - '-addr' - при запуске 'slave' указывает адрес/порт для инициализации 
    сервера;
    - '-quorum' - позволяет указать кворум - кол-во slave-нод, которые должны 
    cовпасть по результатам; если quorum не указан, то вычисляется значение по 
    умолчанию на основе кол-ва указанных slave-нод при запуске мастера;
- Реализован Graceful shutdown по Interrupt и SIGTERM.

---

## Требования

- Go 1.20+
- среда запуска (для интеграционного теста): Linux / WSL + утилита `make`

---

## Сборка

```bash
make build
```

или вручную:
```bash
go build -o mygrep ./cmd/app.go
```

## Запуск

### Запуск slave

```bash
./mygrep -mode=slave -addr=8080
```

В '-addr' достаточно указать только порт, если требуется запустить slave-ноду на локальной машине.

Можно(и даже нужно) поднять несколько slave-нод:

```bash
./mygrep -mode=slave -addr=8080
./mygrep -mode=slave -addr=8081
./mygrep -mode=slave -addr=8082
```

### Запуск master

```bash
./mygrep -mode=master \
  -node=localhost:8080 \
  -node=localhost:8081 \
  -node=localhost:8082 \
  -F abc test.txt
```

## Тесты

**Интеграционный:**

```bash
make integration
```

Что делает:
- Собирает бинарник
- Поднимает несколько slave
- Запускает master
- Запускает системный grep
- Сравнивает результаты через diff
- Останавливает slave(pkill всех 'mygrep' процессов)

**Unit-тесты:**

```bash
go test ./...
```

## Структура проекта

```
cmd/
    app.go      - точка входа в приложение
internal/
    appmode/    - один пакет, в котором описана логика работы master/slave режимов
    model/      - хранилище разделяемых структур данных
    parser/     - пакет для чтения параметров запуска - os.Args
    processor/  - центр управления обработкой входящих данных в slave-режиме
    qaggr/      - производит обработку собранных от slave-нод результатов
    reader/     - читает вход - открывает и читает файл/файлы или stdIn
    transport/  - транспортный слой slave-режима(хендлеры + фабрика экземпляра сервера)
Makefile        - интеграционный тест
README.md
...
```

## Ограничения

- Нет динамического обнаружения slave-нод - требуется их явное указание при запуске 
master-ноды.
- Нет ретраев запросов/респонсов.
- При многократном запуске интеграционного теста ОС может не успевать освободить 
порты, поэтому ноды в slave-режиме могут выдавать ошибки запуска сервера, но как 
правило это не отражается на работоспособности теста.
- Нет реализации потоковой отправки входных данных slave-нодам, но для этого придется 
внести весомые архитектурные изменения в логику формирования задач.
